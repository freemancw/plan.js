<HEAD>
<TITLE>Motion Strategy Library</TITLE>
</HEAD>

<body bgcolor="#ffffff">

<center><img src="msl.jpg"></center>

<p>


<!-- Generated by Doxygen 1.2.2 on Wed Aug 29 23:26:45 2001 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>rrtslide.C</h1><a href="rrtslide_C.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">//----------------------------------------------------------------------</font>
00002 <font class="comment">//               The Motion Strategy Library (MSL)</font>
00003 <font class="comment">//----------------------------------------------------------------------</font>
00004 <font class="comment">//</font>
00005 <font class="comment">// Copyright (c) 1998-2001 Iowa State University and Steve LaValle.  </font>
00006 <font class="comment">// All Rights Reserved.</font>
00007 <font class="comment">// </font>
00008 <font class="comment">// Permission to use, copy, and distribute this software and its </font>
00009 <font class="comment">// documentation is hereby granted free of charge, provided that </font>
00010 <font class="comment">// (1) it is not a component of a commercial product, and </font>
00011 <font class="comment">// (2) this notice appears in all copies of the software and</font>
00012 <font class="comment">//     related documentation. </font>
00013 <font class="comment">// </font>
00014 <font class="comment">// Iowa State University and the author make no representations</font>
00015 <font class="comment">// about the suitability or fitness of this software for any purpose.  </font>
00016 <font class="comment">// It is provided "as is" without express or implied warranty.</font>
00017 <font class="comment">//----------------------------------------------------------------------</font>
00018 
00019 
00020 <font class="preprocessor">#include "<a class="code" href="rrtslide_h.html">rrtslide.h</a>"</font>
00021 
00022 
00023 <font class="comment">// *********************************************************************</font>
00024 <font class="comment">// *********************************************************************</font>
00025 <font class="comment">// CLASS:     RRTSlide</font>
00026 <font class="comment">//</font>
00027 <font class="comment">// *********************************************************************</font>
00028 <font class="comment">// *********************************************************************</font>
00029 
00030 
<a name="l00031"></a><a class="code" href="class_RRTSlide.html#a0">00031</a> <a class="code" href="class_RRTSlide.html#a0">RRTSlide::RRTSlide</a>(<a class="code" href="class_Problem.html">Problem</a> *p):<a class="code" href="class_RRTCon.html">RRTCon</a>(p) {
00032   <font class="keywordtype">int</font> i;
00033   
00034   NumNodes = 100;  <font class="comment">// Each node is costly</font>
00035   RandomTrials = 50;
00036   <font class="comment">// Initialize the random directions</font>
00037   NumDirections = 1000;
00038   RandomDirections = vector&lt;MSLVector&gt;(NumDirections);
00039   <font class="keywordflow">for</font> (i = 0; i &lt; NumDirections; i++) {
00040     RandomDirections[i] = <a class="code" href="class_RRTSlide.html#a4">RandomDirection</a>();
00041   }
00042 }
00043 
00044 
<a name="l00045"></a><a class="code" href="class_RRTSlide.html#a2">00045</a> <a class="code" href="class_MSLVector.html">MSLVector</a> <a class="code" href="class_RRTSlide.html#a2">RRTSlide::SelectInput</a>(<font class="keyword">const</font> <a class="code" href="class_MSLVector.html">MSLVector</a> &amp;x1, <font class="keyword">const</font> <a class="code" href="class_MSLVector.html">MSLVector</a> &amp;x2, 
00046                                 <a class="code" href="class_MSLVector.html">MSLVector</a> &amp;nx_best, <font class="keywordtype">bool</font> &amp;success,
00047                                 <font class="keywordtype">bool</font> forward = <font class="keyword">true</font>)<font class="keyword">
</font>00048 <font class="keyword"></font>{
00049   <a class="code" href="class_MSLVector.html">MSLVector</a> u_best,nx,tu;
00050   list&lt;MSLVector&gt;::iterator u;
00051   <font class="keywordtype">double</font> d,d_min;
00052   success = <font class="keyword">false</font>;
00053   <font class="keywordtype">int</font> i;
00054   d_min = (forward) ? P-&gt;Metric(x1,x2) : P-&gt;Metric(x2,x1);
00055   list&lt;MSLVector&gt; il = P-&gt;GetInputs(x1);
00056 
00057   <font class="keywordflow">if</font> (Holonomic) { <font class="comment">// Just do interpolation</font>
00058 
00059     <font class="comment">// First try the best direction</font>
00060     u_best = P-&gt;InterpolateState(x1,x2,0.1) - x1;
00061     u_best = u_best.<a class="code" href="class_MSLVector.html#a15">norm</a>(); <font class="comment">// Normalize the direction</font>
00062     nx_best = P-&gt;Integrate(x1,u_best,PlannerDeltaT);
00063     SatisfiedCount++;
00064     <font class="keywordflow">if</font> (P-&gt;Satisfied(nx_best)) {
00065       <font class="comment">//if (forward)</font>
00066       <font class="comment">//        cout &lt;&lt; "H" &lt;&lt; flush;</font>
00067       success = <font class="keyword">true</font>;
00068       <font class="keywordflow">return</font> u_best;
00069     }
00070 
00071     <font class="comment">// Now try some random inputs</font>
00072     <font class="keywordflow">for</font> (i = 0; i &lt; RandomTrials; i++) {
00073       tu = RandomDirections[i];
00074       nx = P-&gt;Integrate(x1,tu,PlannerDeltaT);
00075       d = P-&gt;Metric(nx,x2);
00076       SatisfiedCount++;
00077       <font class="keywordflow">if</font> ((d &lt; d_min)&amp;&amp;(x1 != nx)) { 
00078         <font class="keywordflow">if</font> (P-&gt;Satisfied(nx)) {
00079           d_min = d; u_best = tu; nx_best = nx; success = <font class="keyword">true</font>;
00080           <font class="keywordflow">if</font> (forward) {
00081             <font class="comment">//cout &lt;&lt; "R"; </font>
00082             <font class="comment">//cout &lt;&lt; "  i: " &lt;&lt; i &lt;&lt; "  d: " &lt;&lt; </font>
00083             <font class="comment">//  P-&gt;DistanceComp(P-&gt;StateToConfiguration(nx)) &lt;&lt; "\n";</font>
00084           }
00085           <font class="keywordflow">return</font> u_best;
00086         }
00087       }      
00088     }
00089   }
00090   <font class="keywordflow">else</font> {
00091   
00092     <font class="comment">// This will be called whenever the best input fails for holonomic case!</font>
00093     <font class="comment">// Nonholonomic (the more general case -- look at Inputs)</font>
00094     <a class="code" href="defs_h.html#a8">forall</a>(u,il)<font class="keyword"> </font>{
00095       <font class="keywordflow">if</font> (forward)
00096         nx = P-&gt;Integrate(x1,*u,PlannerDeltaT);
00097       <font class="keywordflow">else</font>
00098         nx = P-&gt;Integrate(x1,*u,-PlannerDeltaT);
00099       
00100       d  = (forward) ? P-&gt;Metric(nx,x2): P-&gt;Metric(x2,nx);
00101       
00102       SatisfiedCount++;
00103       
00104       <font class="keywordflow">if</font> ((d &lt; d_min)&amp;&amp;(x1 != nx)) { 
00105         <font class="keywordflow">if</font> (P-&gt;Satisfied(nx)) {
00106           d_min = d; u_best = *u; nx_best = nx; success = <font class="keyword">true</font>;
00107         }
00108       }
00109     }
00110   }
00111 
00112   <font class="comment">//cout &lt;&lt; "u_best: " &lt;&lt; u_best &lt;&lt; "\n";</font>
00113   <font class="keywordflow">if</font> (forward) {
00114     <font class="keywordflow">if</font> (!success)
00115       cout &lt;&lt; <font class="stringliteral">"  F"</font>;
00116   }
00117 
00118   <font class="keywordflow">return</font> u_best;
00119 }
00120 
00121 
00122 
<a name="l00123"></a><a class="code" href="class_RRTSlide.html#a3">00123</a> <font class="keywordtype">bool</font> <a class="code" href="class_RRTSlide.html#a3">RRTSlide::Connect</a>(<font class="keyword">const</font> <a class="code" href="class_MSLVector.html">MSLVector</a> &amp;x, 
00124                        <a class="code" href="class_MSLTree.html">MSLTree</a> *t,
00125                        <a class="code" href="class_MSLNode.html">MSLNode</a> *&amp;nn, <font class="keywordtype">bool</font> forward = <font class="keyword">true</font>)<font class="keyword"> </font>{
00126   <a class="code" href="class_MSLNode.html">MSLNode</a> *nn_prev,*n_best;
00127   <a class="code" href="class_MSLVector.html">MSLVector</a> nx,nx_prev,u_best;
00128   <font class="keywordtype">bool</font> success;
00129   <font class="keywordtype">double</font> d,d_prev,clock,tstep;
00130   <font class="keywordtype">int</font> steps;
00131 
00132   tstep = PlannerDeltaT;
00133   <font class="keywordflow">if</font> ((!Holonomic)&amp;&amp;(!forward))
00134     tstep *= -1.0;
00135 
00136   n_best = <a class="code" href="class_RRT.html#b1">SelectNode</a>(x,t,forward);
00137 
00138   <font class="keywordflow">if</font> (forward) 
00139     cout &lt;&lt;
00140       <font class="stringliteral">"CONNECT  d: "</font> &lt;&lt; 
00141       P-&gt;DistanceComp(P-&gt;StateToConfiguration(n_best-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>())); 
00142   <font class="comment">//     &lt;&lt; "\n";</font>
00143 
00144   u_best = <a class="code" href="class_RRTSlide.html#a2">SelectInput</a>(n_best-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>(),x,nx,success,forward); 
00145   steps = 0;
00146            <font class="comment">// nx gets next state</font>
00147   <font class="keywordflow">if</font> (success) {   <font class="comment">// If a collision-free input was found</font>
00148     d = P-&gt;Metric(nx,x); d_prev = d;
00149     nx_prev = nx; <font class="comment">// Initialize</font>
00150     nn = n_best;
00151     clock = PlannerDeltaT;
00152     <font class="keywordflow">while</font> ((P-&gt;Satisfied(nx))&amp;&amp;
00153            (clock &lt;= ConnectTimeLimit)&amp;&amp;
00154            (d &lt;= d_prev))
00155       {
00156         SatisfiedCount++;
00157         steps++; <font class="comment">// Number of steps made in connecting</font>
00158         nx_prev = nx;
00159         d_prev = d; nn_prev = nn;
00160 
00161         <font class="comment">// First try the previous input</font>
00162         nx = P-&gt;Integrate(nx_prev,u_best,tstep);
00163         d = P-&gt;Metric(nx,x);
00164 
00165         <font class="comment">// If failure, then try a new input</font>
00166         <font class="keywordflow">if</font> (!(P-&gt;Satisfied(nx))||(d &gt; d_prev)) { 
00167           u_best = <a class="code" href="class_RRTSlide.html#a2">SelectInput</a>(nx_prev,x,nx,success,forward);
00168           d = P-&gt;Metric(nx,x);
00169         }
00170 
00171         clock += PlannerDeltaT;
00172 
00173       }
00174 
00175     nn = t-&gt;<a class="code" href="class_MSLTree.html#a4">Extend</a>(n_best, nx, u_best, PlannerDeltaT);
00176   }
00177 
00178   cout &lt;&lt; <font class="stringliteral">" Steps: "</font> &lt;&lt; steps &lt;&lt; <font class="stringliteral">"\n"</font>;
00179   <font class="keywordflow">return</font> success;
00180 }
00181 
00182 
00183 
00184 <font class="comment">// Generate a MSLVector in a random direction with unit magnitude</font>
<a name="l00185"></a><a class="code" href="class_RRTSlide.html#a4">00185</a> <a class="code" href="class_MSLVector.html">MSLVector</a> <a class="code" href="class_RRTSlide.html#a4">RRTSlide::RandomDirection</a>()<font class="keyword">
</font>00186 <font class="keyword"></font>{
00187   <a class="code" href="class_MSLVector.html">MSLVector</a> delta;
00188   <font class="keywordtype">int</font> i,j,dim;
00189   <font class="keywordtype">double</font> r,w;
00190 
00191   dim = P-&gt;StateDim;
00192 
00193   delta = MSLVector(dim);
00194 
00195   <font class="comment">// Pick a random direction</font>
00196   w = 0.0;
00197   <font class="keywordflow">for</font> (i = 0; i &lt; dim; i++) {
00198     <font class="comment">// Generate sample from N(0,1)</font>
00199     delta[i] = 0.0;
00200     <font class="keywordflow">for</font> (j = 0; j &lt; 12; j++) {
00201       R &gt;&gt; r; delta[i] += r;
00202     }
00203     delta[i] -= 6.0;
00204     w += delta[i]*delta[i];
00205   }
00206   w = sqrt(w);  
00207   <font class="keywordflow">for</font> (i = 0; i &lt; dim; i++) {
00208     delta[i] = delta[i]/w;
00209   }
00210 
00211   <font class="comment">//cout &lt;&lt; "delta: " &lt;&lt; delta &lt;&lt; "\n";</font>
00212   <font class="keywordflow">return</font> delta;
00213 }
</div></pre><HEAD>
<TITLE>Motion Strategy Library</TITLE>
</HEAD>

<p>

<hr>

Web page maintained by 
<a href="http://janowiec.cs.iastate.edu/~lavalle">Steve LaValle</a><br>

Partial support provided by NSF CAREER Award IRI-970228 (LaValle),
Honda Research, and Iowa State University.<br>

Contributors:  Anna Atramentov, Peng Cheng, James Kuffner, Steve LaValle, and Libo Yang.<br>
