<HEAD>
<TITLE>Motion Strategy Library</TITLE>
</HEAD>

<body bgcolor="#ffffff">

<center><img src="msl.jpg"></center>

<p>


<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Problem  Class Reference</h1>An interface class that provides the primary input to a planner. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="problem_h-source.html">problem.h</a>&gt;</code>
<p>
<a href="class_Problem-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a0">Problem</a> (<a class="el" href="class_Geom.html">Geom</a> *geom, <a class="el" href="class_Model.html">Model</a> *model, string path)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Problem must be given any instance of <a class="el" href="class_Geom.html">Geom</a> and any instance of <a class="el" href="class_Model.html">Model</a> from each of their class hierarchies.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a1">~Problem</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Empty destructor.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a2">SetGeom</a> (<a class="el" href="class_Geom.html">Geom</a> *geom)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Change the instance of <a class="el" href="class_Geom.html">Geom</a>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a3">SetModel</a> (<a class="el" href="class_Model.html">Model</a> *model)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Change the instance of <a class="el" href="class_Model.html">Model</a>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual list&lt;<a class="el" href="class_MSLVector.html">MSLVector</a>&gt;&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a4">GetInputs</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return a list of possible inputs, which may depend on state.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual list&lt;<a class="el" href="class_MSLVector.html">MSLVector</a>&gt;&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a5">GetInputs</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return a list of possible inputs.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a6">Integrate</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x, const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;u, const double &amp;deltat)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Perform integration from state x, using input u, over time deltat.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a7">InterpolateState</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x1, const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x2, const double &amp;a)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Linearly interpolate two states while respecting topology.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual double&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a8">Metric</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x1, const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A distance metric defined in <a class="el" href="class_Model.html">Model</a>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a9">StateToConfiguration</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A method that converts a <a class="el" href="class_Model.html">Model</a> state in to a <a class="el" href="class_Geom.html">Geom</a> configuration.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a10">StateDifference</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x1, const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compute a <a class="el" href="class_MSLVector.html">MSLVector</a> based on x2-x1. In R^n, the states are simply subtracted to make the <a class="el" href="class_MSLVector.html">MSLVector</a>. This method exists to make things work correctly for other state-space topologies.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a11">Satisfied</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;x)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This takes the logical AND of CollisionFree from <a class="el" href="class_Geom.html">Geom</a>, and Satisfied from <a class="el" href="class_Model.html">Model</a>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a12">CollisionFree</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;q)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The collision checker passed in from <a class="el" href="class_Geom.html">Geom</a>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual double&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a13">DistanceComp</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;q)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The distance computation algorithm from <a class="el" href="class_Geom.html">Geom</a>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#a14">ConfigurationDifference</a> (const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;q1, const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp;q2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compute a <a class="el" href="class_MSLVector.html">MSLVector</a> based on q2-q1. In R^n, the configurations are simply subtracted to make the <a class="el" href="class_MSLVector.html">MSLVector</a>. This method exists to make things work correctly for other configuration-space topologies.</em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top>string&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m0">FilePath</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The directory in which all files for a problem will be stored.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m1">NumBodies</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The number of rigid bodies.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m2">StateDim</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The dimenson of the state space.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m3">InputDim</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The dimension of the input space.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m4">GeomDim</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The dimension of the geometric model.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m5">LowerState</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="class_MSLVector.html">MSLVector</a> of minimum values for each state variable.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m6">UpperState</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="class_MSLVector.html">MSLVector</a> of maximum values for each state variable.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m7">InitialState</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The starting state for a planner.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m8">GoalState</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The goal state for a planner.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="class_MSLVector.html">MSLVector</a>&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#m9">MaxDeviates</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Maximum displacement of geometry with respect to change in each variable.</em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="class_Geom.html">Geom</a>*&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#n0">G</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Need to define a geometry for collision detection.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="class_Model.html">Model</a>*&nbsp;</td><td valign=bottom><a class="el" href="class_Problem.html#n1">M</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>xdot = f(x,u), integration technique, state bounds.</em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
An interface class that provides the primary input to a planner.
<p>
This interface class contains protected instances of <a class="el" href="class_Geom.html">Geom</a> and <a class="el" href="class_Model.html">Model</a>. Wrappers to methods from <a class="el" href="class_Geom.html">Geom</a> provide collision detection and distance computation. Wrappers to methods from <a class="el" href="class_Model.html">Model</a> provide incremental simulation of a kinematic or dynamical system. It is expected a planner can get all (or nearly all) of the information it needs from Problem. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="Problem::Problem"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
Problem::Problem (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="class_Geom.html">Geom</a> * <em>geom</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="class_Model.html">Model</a> * <em>model</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
string <em>path</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Problem must be given any instance of <a class="el" href="class_Geom.html">Geom</a> and any instance of <a class="el" href="class_Model.html">Model</a> from each of their class hierarchies.
<p>
    </td>
  </tr>
</table>
<a name="a1" doxytag="Problem::~Problem"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
Problem::~Problem (
          </b></td>
          <td valign="bottom"><b>
)<code> [inline, virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Empty destructor.
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a12" doxytag="Problem::CollisionFree"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool Problem::CollisionFree (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>q</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The collision checker passed in from <a class="el" href="class_Geom.html">Geom</a>.
<p>
    </td>
  </tr>
</table>
<a name="a14" doxytag="Problem::ConfigurationDifference"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::ConfigurationDifference (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>q1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>q2</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a <a class="el" href="class_MSLVector.html">MSLVector</a> based on q2-q1. In R^n, the configurations are simply subtracted to make the <a class="el" href="class_MSLVector.html">MSLVector</a>. This method exists to make things work correctly for other configuration-space topologies.
<p>
    </td>
  </tr>
</table>
<a name="a13" doxytag="Problem::DistanceComp"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
double Problem::DistanceComp (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>q</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The distance computation algorithm from <a class="el" href="class_Geom.html">Geom</a>.
<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="Problem::GetInputs"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
list&lt; <a class="el" href="class_MSLVector.html">MSLVector</a> &gt; Problem::GetInputs (
          </b></td>
          <td valign="bottom"><b>
)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a list of possible inputs.
<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="Problem::GetInputs"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
list&lt; <a class="el" href="class_MSLVector.html">MSLVector</a> &gt; Problem::GetInputs (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a list of possible inputs, which may depend on state.
<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="Problem::Integrate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::Integrate (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>u</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const double &amp; <em>deltat</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform integration from state x, using input u, over time deltat.
<p>
    </td>
  </tr>
</table>
<a name="a7" doxytag="Problem::InterpolateState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::InterpolateState (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const double &amp; <em>a</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Linearly interpolate two states while respecting topology.
<p>
If a=0, then x1 is returned; if a=1, then x2 is returned. All intermediate values of $a \in [0,1]$ yield intermediate states. This method is defined by <a class="el" href="class_Model.html">Model</a>.     </td>
  </tr>
</table>
<a name="a8" doxytag="Problem::Metric"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
double Problem::Metric (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x2</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A distance metric defined in <a class="el" href="class_Model.html">Model</a>.
<p>
    </td>
  </tr>
</table>
<a name="a11" doxytag="Problem::Satisfied"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool Problem::Satisfied (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This takes the logical AND of CollisionFree from <a class="el" href="class_Geom.html">Geom</a>, and Satisfied from <a class="el" href="class_Model.html">Model</a>.
<p>
    </td>
  </tr>
</table>
<a name="a2" doxytag="Problem::SetGeom"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void Problem::SetGeom (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="class_Geom.html">Geom</a> * <em>geom</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the instance of <a class="el" href="class_Geom.html">Geom</a>.
<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="Problem::SetModel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void Problem::SetModel (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="class_Model.html">Model</a> * <em>model</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the instance of <a class="el" href="class_Model.html">Model</a>.
<p>
    </td>
  </tr>
</table>
<a name="a10" doxytag="Problem::StateDifference"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::StateDifference (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x2</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute a <a class="el" href="class_MSLVector.html">MSLVector</a> based on x2-x1. In R^n, the states are simply subtracted to make the <a class="el" href="class_MSLVector.html">MSLVector</a>. This method exists to make things work correctly for other state-space topologies.
<p>
    </td>
  </tr>
</table>
<a name="a9" doxytag="Problem::StateToConfiguration"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::StateToConfiguration (
          </b></td>
          <td valign="bottom"><b>
const <a class="el" href="class_MSLVector.html">MSLVector</a> &amp; <em>x</em>&nbsp;)<code> [virtual]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A method that converts a <a class="el" href="class_Model.html">Model</a> state in to a <a class="el" href="class_Geom.html">Geom</a> configuration.
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="m0" doxytag="Problem::FilePath"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
string Problem::FilePath
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The directory in which all files for a problem will be stored.
<p>
    </td>
  </tr>
</table>
<a name="n0" doxytag="Problem::G"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_Geom.html">Geom</a> * Problem::G<code> [protected]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Need to define a geometry for collision detection.
<p>
    </td>
  </tr>
</table>
<a name="m4" doxytag="Problem::GeomDim"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int Problem::GeomDim
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The dimension of the geometric model.
<p>
    </td>
  </tr>
</table>
<a name="m8" doxytag="Problem::GoalState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::GoalState
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The goal state for a planner.
<p>
    </td>
  </tr>
</table>
<a name="m7" doxytag="Problem::InitialState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::InitialState
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The starting state for a planner.
<p>
    </td>
  </tr>
</table>
<a name="m3" doxytag="Problem::InputDim"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int Problem::InputDim
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The dimension of the input space.
<p>
    </td>
  </tr>
</table>
<a name="m5" doxytag="Problem::LowerState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::LowerState
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="class_MSLVector.html">MSLVector</a> of minimum values for each state variable.
<p>
    </td>
  </tr>
</table>
<a name="n1" doxytag="Problem::M"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_Model.html">Model</a> * Problem::M<code> [protected]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
xdot = f(x,u), integration technique, state bounds.
<p>
    </td>
  </tr>
</table>
<a name="m9" doxytag="Problem::MaxDeviates"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::MaxDeviates
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Maximum displacement of geometry with respect to change in each variable.
<p>
    </td>
  </tr>
</table>
<a name="m1" doxytag="Problem::NumBodies"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int Problem::NumBodies
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The number of rigid bodies.
<p>
    </td>
  </tr>
</table>
<a name="m2" doxytag="Problem::StateDim"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int Problem::StateDim
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The dimenson of the state space.
<p>
    </td>
  </tr>
</table>
<a name="m6" doxytag="Problem::UpperState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
<a class="el" href="class_MSLVector.html">MSLVector</a> Problem::UpperState
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="class_MSLVector.html">MSLVector</a> of maximum values for each state variable.
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="problem_h-source.html">problem.h</a></ul>
<HEAD>
<TITLE>Motion Strategy Library</TITLE>
</HEAD>

<p>

<hr>

Web page maintained by 
<a href="http://janowiec.cs.iastate.edu/~lavalle">Steve LaValle</a><br>

Partial support provided by NSF CAREER Award IRI-970228 (LaValle),
Honda Research.<br>

Contributors:  Anna Atramentov, Peng Cheng, James Kuffner, Steve LaValle, and Libo Yang.<br>
