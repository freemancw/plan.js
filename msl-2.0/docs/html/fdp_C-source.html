<HEAD>
<TITLE>Motion Strategy Library</TITLE>
</HEAD>

<body bgcolor="#ffffff">

<center><img src="msl.jpg"></center>

<p>


<!-- Generated by Doxygen 1.2.2 on Wed Aug 29 23:26:43 2001 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>fdp.C</h1><a href="fdp_C.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">//----------------------------------------------------------------------</font>
00002 <font class="comment">//               The Motion Strategy Library (MSL)</font>
00003 <font class="comment">//----------------------------------------------------------------------</font>
00004 <font class="comment">//</font>
00005 <font class="comment">// Copyright (c) 1998-2000 Iowa State University and Steve LaValle.  </font>
00006 <font class="comment">// All Rights Reserved.</font>
00007 <font class="comment">// </font>
00008 <font class="comment">// Permission to use, copy, and distribute this software and its </font>
00009 <font class="comment">// documentation is hereby granted free of charge, provided that </font>
00010 <font class="comment">// (1) it is not a component of a commercial product, and </font>
00011 <font class="comment">// (2) this notice appears in all copies of the software and</font>
00012 <font class="comment">//     related documentation. </font>
00013 <font class="comment">// </font>
00014 <font class="comment">// Iowa State University and the author make no representations</font>
00015 <font class="comment">// about the suitability or fitness of this software for any purpose.  </font>
00016 <font class="comment">// It is provided "as is" without express or implied warranty.</font>
00017 <font class="comment">//----------------------------------------------------------------------</font>
00018 
00019 <font class="preprocessor">#include &lt;math.h&gt;</font>
00020 <font class="preprocessor">#include &lt;stdio.h&gt;</font>
00021 
00022 <font class="preprocessor">#include "<a class="code" href="fdp_h.html">fdp.h</a>"</font>
00023 <font class="preprocessor">#include "<a class="code" href="defs_h.html">defs.h</a>"</font>
00024 
00025 <font class="comment">// This is needed because g++ does not support ANSI export keyword!</font>
00026 <font class="preprocessor">#include "<a class="code" href="marray_C.html">marray.C</a>"</font>
00027 
00028 
00029 <font class="comment">// *********************************************************************</font>
00030 <font class="comment">// *********************************************************************</font>
00031 <font class="comment">// CLASS:     FDP base class</font>
00032 <font class="comment">// </font>
00033 <font class="comment">// *********************************************************************</font>
00034 <font class="comment">// *********************************************************************</font>
00035 
<a name="l00036"></a><a class="code" href="class_FDP.html#a0">00036</a> <a class="code" href="class_FDP.html#a0">FDP::FDP</a>(<a class="code" href="class_Problem.html">Problem</a> *problem): <a class="code" href="class_IncrementalPlanner.html">IncrementalPlanner</a>(problem) {
00037 
00038   GridDefaultResolution = 50;
00039   <a class="code" href="class_FDP.html#a2">Reset</a>();
00040 }
00041 
00042 
00043 
<a name="l00044"></a><a class="code" href="class_FDP.html#a2">00044</a> <font class="keywordtype">void</font> <a class="code" href="class_FDP.html#a2">FDP::Reset</a>()<font class="keyword"> </font>{
00045   <font class="keywordtype">int</font> i,dim;
00046   <font class="keywordtype">bool</font> done;
00047 
00048   <a class="code" href="class_Planner.html#a2">IncrementalPlanner::Reset</a>();
00049 
00050   SatisfiedCount = 0;
00051   NumNodes = 20000;
00052 
00053   GridDimensions = vector&lt;int&gt;(P-&gt;StateDim);
00054   <font class="keywordflow">for</font> (i = 0; i &lt; P-&gt;StateDim; i++)
00055     GridDimensions[i] = GridDefaultResolution;
00056   <font class="keywordflow">if</font> (<a class="code" href="util_C.html#a6">is_file</a>(P-&gt;FilePath + "GridDimensions")) {
00057     ifstream fin((P-&gt;FilePath + "GridDimensions").c_str());
00058     <font class="keywordflow">for</font> (i = 0; i &lt; P-&gt;StateDim; i++) {
00059       fin &gt;&gt; dim; 
00060       GridDimensions[i] = dim;
00061     }
00062     fin.close();
00063   }
00064   
00065   Grid = <font class="keyword">new</font> <a class="code" href="class_MultiArray.html">MultiArray&lt;int&gt;</a>(GridDimensions, 0);
00066 
00067   Quantization = MSLVector(P-&gt;StateDim);
00068 
00069   <font class="keywordflow">for</font> (i = 0; i &lt; P-&gt;StateDim; i++) {
00070     Quantization[i] = (P-&gt;UpperState[i] - P-&gt;LowerState[i])/
00071       (GridDimensions[i]);
00072   }
00073 
00074   <font class="keywordflow">if</font> (!<a class="code" href="util_C.html#a6">is_file</a>(P-&gt;FilePath+"GapError")) {
00075     <font class="keywordflow">for</font> (i = 0; i &lt; P-&gt;StateDim; i++)
00076       GapError[i] = Quantization[i] / 2.0;
00077   }
00078 
00079   <font class="comment">// Mark the collision region</font>
00080   vector&lt;int&gt; indices(P-&gt;StateDim);
00081   <font class="keywordflow">for</font> (i = 0; i &lt; P-&gt;StateDim; i++)
00082     indices[i] = 0;
00083 
00084   <font class="comment">// Loop through all of the indices and check each for collision</font>
00085   cout &lt;&lt; <font class="stringliteral">"Performing collision detection to initialize grid.\n"</font>;
00086   done = <font class="keyword">false</font>;
00087   <font class="keywordflow">while</font> (!done) {
00088     (*Grid)[indices] = 
00089       (P-&gt;Satisfied(<a class="code" href="class_FDP.html#b2">IndicesToState</a>(indices))) ? UNVISITED : COLLISION;
00090     done = Grid-&gt;<a class="code" href="class_MultiArray.html#a5">Increment</a>(indices); <font class="comment">// This modifies indices</font>
00091   }
00092   cout &lt;&lt; <font class="stringliteral">"Finished.\n"</font>;
00093 }
00094 
00095 
00096 
<a name="l00097"></a><a class="code" href="class_FDP.html#a3">00097</a> <font class="keywordtype">bool</font> <a class="code" href="class_FDP.html#a3">FDP::Plan</a>()<font class="keyword">
</font>00098 <font class="keyword"></font>{
00099   <font class="keywordtype">int</font> i;
00100   <a class="code" href="class_MSLNode.html">MSLNode</a> *n,*nn;
00101   <a class="code" href="class_MSLVector.html">MSLVector</a> nx,x;
00102   <font class="keywordtype">double</font> ptime;
00103   list&lt;MSLNode*&gt; path;
00104   <font class="keywordtype">double</font> cost;
00105   vector&lt;int&gt; indices;
00106   list&lt;MSLVector&gt;::iterator u;
00107   list&lt;MSLNode*&gt;::iterator ni;
00108   list&lt;MSLVector&gt; ulist;
00109 
00110   <font class="comment">// Make the root node of G</font>
00111   <font class="keywordflow">if</font> (!T) {
00112     T = <font class="keyword">new</font> MSLTree(P-&gt;InitialState);
00113     T-&gt;Root()-&gt;SetCost(0.0);
00114     Q.push(T-&gt;Root());  <font class="comment">// Add the root node to the queue</font>
00115   }
00116 
00117   i = 0;
00118   <font class="keywordflow">while</font> ((i &lt; NumNodes)&amp;&amp;
00119          (!Q.empty())) {
00120 
00121     <font class="comment">// Remove the element with smallest cost</font>
00122     n = Q.top();
00123     cost = n-&gt;<a class="code" href="class_MSLNode.html#a5">Cost</a>();
00124     Q.pop();
00125     x = n-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>();
00126 
00127     <font class="comment">// Try all inputs</font>
00128     ulist = P-&gt;GetInputs(x);
00129     <a class="code" href="defs_h.html#a8">forall</a>(u,ulist)<font class="keyword"> </font>{
00130       nx = P-&gt;Integrate(x,*u,PlannerDeltaT);
00131       indices = <a class="code" href="class_FDP.html#b1">StateToIndices</a>(nx);
00132       <font class="comment">// If we are visiting an UNVISITED place...</font>
00133       <font class="keywordflow">if</font> ((*Grid)[indices] == UNVISITED) {
00134         (*Grid)[indices] = VISITED;
00135         <font class="comment">// Make a new node and edge</font>
00136         nn = T-&gt;Extend(n,nx,*u,PlannerDeltaT); <font class="comment">// Make a new node with state nx</font>
00137         nn-&gt;<a class="code" href="class_MSLNode.html#a6">SetCost</a>(<a class="code" href="class_FDP.html#b0">SearchCost</a>(cost,n,nn));
00138         Q.push(nn); <font class="comment">// Put it into the priority queue</font>
00139         <font class="comment">//cout &lt;&lt; "New node: " &lt;&lt; nn-&gt;State() &lt;&lt; "  " &lt;&lt; nn-&gt;Cost() &lt;&lt; "\n";</font>
00140 
00141         <font class="comment">// Check if goal reached</font>
00142         <font class="keywordflow">if</font> (<a class="code" href="class_Planner.html#a7">GapSatisfied</a>(nn-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>(),P-&gt;GoalState)) { 
00143           cout &lt;&lt; <font class="stringliteral">"Successful Path Found\n"</font>;
00144           path = T-&gt;PathToRoot(nn); path.reverse();
00145           <font class="comment">// Make the correct times</font>
00146           ptime = 0.0; TimeList.clear();
00147           <a class="code" href="defs_h.html#a8">forall</a>(ni,path)<font class="keyword"> </font>{
00148             ptime += (*ni)-&gt;Time();
00149             TimeList.push_back(ptime);
00150           }
00151 
00152           <a class="code" href="class_IncrementalPlanner.html#a3">RecordSolution</a>(path); <font class="comment">// Write to Path and Policy</font>
00153           <font class="keywordflow">return</font> <font class="keyword">true</font>;
00154         }
00155       }
00156     }
00157 
00158     i++;
00159   }
00160 
00161   cout &lt;&lt; <font class="stringliteral">"Failure to find a path\n"</font>;
00162   <font class="keywordflow">return</font> <font class="keyword">false</font>;
00163 }
00164 
00165 
<a name="l00166"></a><a class="code" href="class_FDP.html#b0">00166</a> <font class="keywordtype">double</font> <a class="code" href="class_FDP.html#b0">FDP::SearchCost</a>(<font class="keywordtype">double</font> initcost, <a class="code" href="class_MSLNode.html">MSLNode</a>* &amp;n, <a class="code" href="class_MSLNode.html">MSLNode</a>* &amp;nn)<font class="keyword"> </font>{
00167   <font class="keywordflow">return</font> initcost + PlannerDeltaT;
00168 }
00169 
00170 
00171 
00172 
<a name="l00173"></a><a class="code" href="class_FDP.html#b1">00173</a> vector&lt;int&gt; <a class="code" href="class_FDP.html#b1">FDP::StateToIndices</a>(<font class="keyword">const</font> <a class="code" href="class_MSLVector.html">MSLVector</a> &amp;x)<font class="keyword"> </font>{
00174   <font class="keywordtype">int</font> i;
00175 
00176   vector&lt;int&gt; indices(P-&gt;StateDim);
00177 
00178   <font class="keywordflow">for</font> (i = 0; i &lt; P-&gt;StateDim; i++) {
00179     indices[i] = (<font class="keywordtype">int</font>) ((x[i] - P-&gt;LowerState[i])/Quantization[i]);
00180     <font class="comment">// These are needed because the state is sometimes out of bounds.</font>
00181     <font class="comment">// The other way to fix this is to ensure that every instance of</font>
00182     <font class="comment">// Integrate in Model and subclasses stays within bounds.</font>
00183     <font class="keywordflow">if</font> (indices[i] &lt; 0)
00184       indices[i] = 0;
00185     <font class="keywordflow">if</font> (indices[i] &gt;= GridDimensions[i])
00186       indices[i] = GridDimensions[i] - 1;
00187   }
00188 
00189   <font class="keywordflow">return</font> indices;
00190 }
00191 
00192 
<a name="l00193"></a><a class="code" href="class_FDP.html#b2">00193</a> <a class="code" href="class_MSLVector.html">MSLVector</a> <a class="code" href="class_FDP.html#b2">FDP::IndicesToState</a>(<font class="keyword">const</font> vector&lt;int&gt; &amp;indices)<font class="keyword"> </font>{
00194   <font class="keywordtype">int</font> i;
00195 
00196   <a class="code" href="class_MSLVector.html">MSLVector</a> x(P-&gt;StateDim);
00197   <font class="keywordflow">for</font> (i = 0; i &lt; P-&gt;StateDim; i++) {
00198     x[i] = Quantization[i]*(indices[i]+0.5) + P-&gt;LowerState[i];
00199   }
00200 
00201   <font class="keywordflow">return</font> x;
00202 }
00203 
00204 
00205 <font class="comment">// *********************************************************************</font>
00206 <font class="comment">// *********************************************************************</font>
00207 <font class="comment">// CLASS:     FDPStar</font>
00208 <font class="comment">// </font>
00209 <font class="comment">// *********************************************************************</font>
00210 <font class="comment">// *********************************************************************</font>
00211 
<a name="l00212"></a><a class="code" href="class_FDPStar.html#a0">00212</a> <a class="code" href="class_FDPStar.html#a0">FDPStar::FDPStar</a>(<a class="code" href="class_Problem.html">Problem</a> *problem): <a class="code" href="class_FDP.html">FDP</a>(problem) {
00213 }
00214 
00215 
00216 <font class="comment">// The cost always represents the cost to come using the Metric</font>
00217 <font class="comment">// for each step, plus the cost to go from nn to the goal.</font>
<a name="l00218"></a><a class="code" href="class_FDPStar.html#b0">00218</a> <font class="keywordtype">double</font> <a class="code" href="class_FDPStar.html#b0">FDPStar::SearchCost</a>(<font class="keywordtype">double</font> initcost, <a class="code" href="class_MSLNode.html">MSLNode</a>* &amp;n, <a class="code" href="class_MSLNode.html">MSLNode</a>* &amp;nn)<font class="keyword"> </font>{
00219   <font class="keywordflow">return</font> initcost - 
00220     P-&gt;Metric(n-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>(),P-&gt;GoalState) +
00221     P-&gt;Metric(n-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>(),nn-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>()) + 
00222     P-&gt;Metric(nn-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>(),P-&gt;GoalState);
00223 }
00224 
00225 
00226 
00227 <font class="comment">// *********************************************************************</font>
00228 <font class="comment">// *********************************************************************</font>
00229 <font class="comment">// CLASS:     FDPBestFirst</font>
00230 <font class="comment">// </font>
00231 <font class="comment">// *********************************************************************</font>
00232 <font class="comment">// *********************************************************************</font>
00233 
<a name="l00234"></a><a class="code" href="class_FDPBestFirst.html#a0">00234</a> <a class="code" href="class_FDPBestFirst.html#a0">FDPBestFirst::FDPBestFirst</a>(<a class="code" href="class_Problem.html">Problem</a> *problem): <a class="code" href="class_FDP.html">FDP</a>(problem) {
00235 }
00236 
00237 
<a name="l00238"></a><a class="code" href="class_FDPBestFirst.html#b0">00238</a> <font class="keywordtype">double</font> <a class="code" href="class_FDPBestFirst.html#b0">FDPBestFirst::SearchCost</a>(<font class="keywordtype">double</font> initcost, <a class="code" href="class_MSLNode.html">MSLNode</a>* &amp;n,
00239                                 <a class="code" href="class_MSLNode.html">MSLNode</a>* &amp;nn)<font class="keyword"> </font>{
00240   <font class="keywordflow">return</font> P-&gt;Metric(n-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>(),P-&gt;GoalState);
00241 }
00242 
00243 
00244 
00245 
00246 
00247 <font class="comment">// *********************************************************************</font>
00248 <font class="comment">// *********************************************************************</font>
00249 <font class="comment">// CLASS:     FDPBi</font>
00250 <font class="comment">// </font>
00251 <font class="comment">// *********************************************************************</font>
00252 <font class="comment">// *********************************************************************</font>
00253 
<a name="l00254"></a><a class="code" href="class_FDPBi.html#a0">00254</a> <a class="code" href="class_FDPBi.html#a0">FDPBi::FDPBi</a>(<a class="code" href="class_Problem.html">Problem</a> *problem): <a class="code" href="class_FDP.html">FDP</a>(problem) {
00255 }
00256 
00257 
00258 
<a name="l00259"></a><a class="code" href="class_FDPBi.html#a2">00259</a> <font class="keywordtype">void</font> <a class="code" href="class_FDPBi.html#a2">FDPBi::Reset</a>()<font class="keyword"> </font>{
00260   <a class="code" href="class_FDP.html#a2">FDP::Reset</a>();
00261 }
00262 
00263 
00264 
<a name="l00265"></a><a class="code" href="class_FDPBi.html#a3">00265</a> <font class="keywordtype">bool</font> <a class="code" href="class_FDPBi.html#a3">FDPBi::Plan</a>()<font class="keyword">
</font>00266 <font class="keyword"></font>{
00267   <font class="keywordtype">int</font> i,k;
00268   <a class="code" href="class_MSLNode.html">MSLNode</a> *n,*nn,*nn2;
00269   <a class="code" href="class_MSLVector.html">MSLVector</a> nx,x;
00270   <font class="keywordtype">double</font> ptime;
00271   list&lt;MSLNode*&gt; path,nlist;
00272   <font class="keywordtype">double</font> cost;
00273   vector&lt;int&gt; indices,indices2;
00274   <font class="keywordtype">bool</font> match;
00275   list&lt;MSLVector&gt;::iterator u;
00276   list&lt;MSLNode*&gt;::iterator ni;
00277   list&lt;MSLVector&gt; ulist;
00278 
00279   <font class="comment">// Make the root node of T</font>
00280   <font class="keywordflow">if</font> (!T) {
00281     T = <font class="keyword">new</font> MSLTree(P-&gt;InitialState);
00282     T-&gt;Root()-&gt;SetCost(0.0);
00283     Q.push(T-&gt;Root());  <font class="comment">// Add the root node to the queue</font>
00284   }
00285 
00286   <font class="comment">// Make the root node of T2</font>
00287   <font class="keywordflow">if</font> (!T2) {
00288     T2 = <font class="keyword">new</font> MSLTree(P-&gt;GoalState);
00289     T2-&gt;Root()-&gt;SetCost(0.0);
00290     Q2.push(T2-&gt;Root());  <font class="comment">// Add the root node to the queue</font>
00291   }
00292 
00293   i = 0;
00294   <font class="keywordflow">while</font> ((i &lt; NumNodes)&amp;&amp;
00295          (!Q.empty())&amp;&amp;
00296          (!Q2.empty())) {
00297 
00298     <font class="comment">// ******** Handle the tree from the initial state *************</font>
00299     <font class="comment">// Remove the element with smallest cost</font>
00300     n = Q.top();
00301     cost = n-&gt;<a class="code" href="class_MSLNode.html#a5">Cost</a>();
00302     Q.pop();
00303     x = n-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>();
00304 
00305     <font class="comment">// Try all inputs</font>
00306     ulist = P-&gt;GetInputs(x);
00307     <a class="code" href="defs_h.html#a8">forall</a>(u,ulist)<font class="keyword"> </font>{
00308       nx = P-&gt;Integrate(x,*u,PlannerDeltaT);
00309       indices = <a class="code" href="class_FDP.html#b1">StateToIndices</a>(nx);
00310 
00311       <font class="comment">// If we are visiting a place visited by T2...</font>
00312       <font class="keywordflow">if</font> ((*Grid)[indices] == VISITED2) {
00313         <font class="comment">// Make a new node and edge</font>
00314         nn = T-&gt;Extend(n,nx,*u,PlannerDeltaT); <font class="comment">// Make a new node with state nx</font>
00315         nn-&gt;<a class="code" href="class_MSLNode.html#a6">SetCost</a>(<a class="code" href="class_FDP.html#b0">SearchCost</a>(cost,n,nn));
00316 
00317         <font class="comment">// Get the node in T2 that was visited</font>
00318         nlist = T2-&gt;Nodes();
00319         <a class="code" href="defs_h.html#a8">forall</a>(ni,nlist)<font class="keyword"> </font>{
00320           indices2 = <a class="code" href="class_FDP.html#b1">StateToIndices</a>((*ni)-&gt;State());
00321           match = <font class="keyword">true</font>;
00322           <font class="keywordflow">for</font> (k = 0; k &lt; P-&gt;StateDim; k++)
00323             <font class="keywordflow">if</font> (indices[k] != indices2[k])
00324               match = <font class="keyword">false</font>;
00325           <font class="keywordflow">if</font> (match)
00326             nn2 = (*ni);
00327         }
00328         <a class="code" href="class_FDPBi.html#b0">RecoverSolution</a>(nn,nn2);
00329         cout &lt;&lt; <font class="stringliteral">"Successful Path Found\n"</font>;
00330         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00331       }
00332 
00333       <font class="comment">// If we are visiting an UNVISITED place...</font>
00334       <font class="keywordflow">if</font> ((*Grid)[indices] == UNVISITED) {
00335         (*Grid)[indices] = VISITED;
00336         <font class="comment">// Make a new node and edge</font>
00337         nn = T-&gt;Extend(n,nx,*u,PlannerDeltaT); <font class="comment">// Make a new node with state nx</font>
00338         nn-&gt;<a class="code" href="class_MSLNode.html#a6">SetCost</a>(<a class="code" href="class_FDP.html#b0">SearchCost</a>(cost,n,nn));
00339         Q.push(nn); <font class="comment">// Put it into the priority queue</font>
00340 
00341         <font class="comment">// Check if goal reached</font>
00342         <font class="keywordflow">if</font> (<a class="code" href="class_Planner.html#a7">GapSatisfied</a>(nn-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>(),P-&gt;GoalState)) { 
00343           cout &lt;&lt; <font class="stringliteral">"Successful Path Found\n"</font>;
00344           path = T-&gt;PathToRoot(nn); path.reverse();
00345           <font class="comment">// Make the correct times</font>
00346           ptime = 0.0; TimeList.clear();
00347           <a class="code" href="defs_h.html#a8">forall</a>(ni,path)<font class="keyword"> </font>{
00348             ptime += (*ni)-&gt;Time();
00349             TimeList.push_back(ptime);
00350           }
00351 
00352           <a class="code" href="class_IncrementalPlanner.html#a3">RecordSolution</a>(path); <font class="comment">// Write to Path and Policy</font>
00353           <font class="keywordflow">return</font> <font class="keyword">true</font>;
00354         }
00355       }
00356     }
00357 
00358     <font class="comment">// ******** Handle the tree from the goal state *************</font>
00359     <font class="comment">// Remove the element with smallest cost</font>
00360     n = Q2.top();
00361     cost = n-&gt;<a class="code" href="class_MSLNode.html#a5">Cost</a>();
00362     Q2.pop();
00363     x = n-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>();
00364 
00365     <font class="comment">// Try all inputs</font>
00366     ulist = P-&gt;GetInputs(x);
00367     <a class="code" href="defs_h.html#a8">forall</a>(u,ulist)<font class="keyword"> </font>{
00368       nx = P-&gt;Integrate(x,*u,-PlannerDeltaT);  <font class="comment">// Reverse time integration</font>
00369       indices = <a class="code" href="class_FDP.html#b1">StateToIndices</a>(nx);
00370 
00371       <font class="comment">// If we are visiting a place visited by T...</font>
00372       <font class="keywordflow">if</font> ((*Grid)[indices] == VISITED) {
00373         <font class="comment">// Make a new node and edge</font>
00374         nn = T2-&gt;Extend(n,nx,*u,PlannerDeltaT); <font class="comment">// Make new node with state nx</font>
00375         nn-&gt;<a class="code" href="class_MSLNode.html#a6">SetCost</a>(<a class="code" href="class_FDP.html#b0">SearchCost</a>(cost,n,nn));
00376 
00377         <font class="comment">// Get the node in T that was visited</font>
00378         nlist = T-&gt;Nodes();
00379         <a class="code" href="defs_h.html#a8">forall</a>(ni,nlist)<font class="keyword"> </font>{
00380           indices2 = <a class="code" href="class_FDP.html#b1">StateToIndices</a>((*ni)-&gt;State());
00381           match = <font class="keyword">true</font>;
00382           <font class="keywordflow">for</font> (k = 0; k &lt; P-&gt;StateDim; k++)
00383             <font class="keywordflow">if</font> (indices[k] != indices2[k])
00384               match = <font class="keyword">false</font>;
00385           <font class="keywordflow">if</font> (match)
00386             nn2 = (*ni);
00387         }
00388         <a class="code" href="class_FDPBi.html#b0">RecoverSolution</a>(nn2,nn);
00389         cout &lt;&lt; <font class="stringliteral">"Successful Path Found\n"</font>;
00390         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00391       }
00392 
00393       <font class="comment">// If we are visiting an UNVISITED place...</font>
00394       <font class="keywordflow">if</font> ((*Grid)[indices] == UNVISITED) {
00395         (*Grid)[indices] = VISITED2;
00396         <font class="comment">// Make a new node and edge</font>
00397         nn = T2-&gt;Extend(n,nx,*u,PlannerDeltaT); <font class="comment">// Make new node with state nx</font>
00398         nn-&gt;<a class="code" href="class_MSLNode.html#a6">SetCost</a>(<a class="code" href="class_FDP.html#b0">SearchCost</a>(cost,n,nn));
00399         Q2.push(nn); <font class="comment">// Put it into the priority queue</font>
00400 
00401         <font class="comment">// Check if initial reached</font>
00402         <font class="keywordflow">if</font> (<a class="code" href="class_Planner.html#a7">GapSatisfied</a>(nn-&gt;<a class="code" href="class_MSLNode.html#a0">State</a>(),P-&gt;InitialState)) { 
00403           cout &lt;&lt; <font class="stringliteral">"Successful Path Found\n"</font>;
00404           path = T2-&gt;PathToRoot(nn); path.reverse();
00405           <font class="comment">// Make the correct times</font>
00406           ptime = 0.0; TimeList.clear();
00407           <a class="code" href="defs_h.html#a8">forall</a>(ni,path)<font class="keyword"> </font>{
00408             ptime += (*ni)-&gt;Time();
00409             TimeList.push_back(ptime);
00410           }
00411 
00412           <a class="code" href="class_IncrementalPlanner.html#a3">RecordSolution</a>(path); <font class="comment">// Write to Path and Policy</font>
00413           <font class="keywordflow">return</font> <font class="keyword">true</font>;
00414         }
00415       }
00416     }
00417 
00418     i++;
00419   }
00420 
00421   cout &lt;&lt; <font class="stringliteral">"Failure to find a path\n"</font>;
00422   <font class="keywordflow">return</font> <font class="keyword">false</font>;
00423 }
00424 
00425 
00426 <font class="comment">// This is duplicated from RRTDual</font>
<a name="l00427"></a><a class="code" href="class_FDPBi.html#b0">00427</a> <font class="keywordtype">void</font> <a class="code" href="class_FDPBi.html#b0">FDPBi::RecoverSolution</a>(<a class="code" href="class_MSLNode.html">MSLNode</a>* &amp;n1, <a class="code" href="class_MSLNode.html">MSLNode</a>* &amp;n2)<font class="keyword"> </font>{
00428   list&lt;MSLNode*&gt; path,path2;
00429   <font class="keywordtype">double</font> ptime;
00430   list&lt;MSLNode*&gt;::iterator n;
00431 
00432   path = T-&gt;PathToRoot(n1); path.reverse();
00433   <font class="comment">// Figure out forward timings</font>
00434   ptime = 0.0; TimeList.clear();
00435   <a class="code" href="defs_h.html#a8">forall</a>(n,path)<font class="keyword"> </font>{
00436     ptime += (*n)-&gt;<a class="code" href="class_MSLNode.html#a4">Time</a>();
00437     TimeList.push_back(ptime);
00438   }
00439   
00440   path2 = T2-&gt;PathToRoot(n2); 
00441   <font class="comment">// Figure out backwards timings</font>
00442   ptime += PlannerDeltaT; <font class="comment">// Add a time step for the gap</font>
00443   <a class="code" href="defs_h.html#a8">forall</a>(n,path2)<font class="keyword">  </font>{ <font class="comment">// Compute total time in T2 part of path</font>
00444     TimeList.push_back(ptime);
00445     ptime += (*n)-&gt;<a class="code" href="class_MSLNode.html#a4">Time</a>();
00446   }
00447   
00448   <font class="comment">//cout &lt;&lt; "Path: " &lt;&lt; path;</font>
00449   <font class="comment">//cout &lt;&lt; "Path2: " &lt;&lt; path2;</font>
00450   <font class="comment">//cout &lt;&lt; "\n TimeList: " &lt;&lt; TimeList &lt;&lt; " L: " &lt;&lt; TimeList.length();</font>
00451 
00452   <a class="code" href="class_IncrementalPlanner.html#a3">RecordSolution</a>(path,path2); <font class="comment">// Write to Path and Policy</font>
00453 }
00454 
00455 
00456 
00457 
00458 
00459 
00460 
00461 
00462 
00463 
</div></pre><HEAD>
<TITLE>Motion Strategy Library</TITLE>
</HEAD>

<p>

<hr>

Web page maintained by 
<a href="http://janowiec.cs.iastate.edu/~lavalle">Steve LaValle</a><br>

Partial support provided by NSF CAREER Award IRI-970228 (LaValle),
Honda Research, and Iowa State University.<br>

Contributors:  Anna Atramentov, Peng Cheng, James Kuffner, Steve LaValle, and Libo Yang.<br>
