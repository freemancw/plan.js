<HEAD>
<TITLE>Motion Strategy Library</TITLE>
</HEAD>

<body bgcolor="#ffffff">

<center><img src="msl.jpg"></center>

<p>


<!-- Generated by Doxygen 1.2.2 on Fri Nov 10 11:03:45 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Motion Strategy Library Main Page</h1>
<p>
<HEAD>
<TITLE>Motion Strategy Library</TITLE>
</HEAD>

<hr>

The Motion Strategy Library (MSL) allows easy development and testing
of motion planning algorithms for a wide variety of applications.  The
software architecture is object-oriented and the general design is
highly modular.  It was developed on a Linux system using GNU C++,
STL, and the <a href="http://www.fox-toolkit.org/">FOX</a> GUI
Toolkit. <p>

The MSL is available as Open Source, free for both academic and
commerical use.  Here is a copy of the <a href="license">licensing
agreement</a>, which offers substantial freedom, to help spread
interest and applications of motion planning algorithms. <p>

Presently MSL includes planners based on <a
href="http://msl.cs.uiuc.edu/rrt/">Rapidly-exploring Random Trees</a>
(RRTs), Probabilistic Roadmaps (PRMs), and forward dynamic programming
(FDP).  If you have any questions or comments regarding the software,
please do not hesitate to send <a
href="mailto:lavalle@cs.uiuc.edu">e-mail</a>.
<p>

<TABLE>
<TR>
<TD>
<dt><A HREF="#A">A. General Overview</A><br>
<dt><A HREF="#B">B. Downloading and Installation</A><br>
<dt><A HREF="#C">C. Help Getting Started</A><br>
<dt><A HREF="#D">D. Known Bugs</A><br>
<dt><A HREF="#E">E. Revision History</A><br>
<dt><A HREF="#F">F. To-Do List</A><br>
<dt><A HREF="#G">G. Contributors</A><br>
</A><br>
</TD>
</TR>
</TABLE>

<hr>

<h2><A NAME="A">A. General Overview</h2>

MSL consists of seven C++ class hierarchies, each of which serving an
independent purpose.  The relationship between these classes is shown
below.<br>

<img src="scheme.jpg">

<br>

This is not an inheritance diagram; it merely shows what information
is passed from one hierarchy to another.  Inheritance diagrams are
included in the <a href="hierarchy.html">Class Hierarchy documentation</a>.

Each of the seven class hierarchies is briefly explained below:
<ul>

<li><b><a href="class_Model.html">Model</a>:</b> 
These contain incremental simulators that model the
kinematics and dynamics of a variety of mechanical systems.  The
methods allow planning algorithms to compute the future system state,
given the current state, an interval of time, and a control input
applied over that interval.  </li> <p>

<li><b><a href="class_Geom.html">Geom</a>:</b> These define the geometric
representations of all obstacles in the world, and of each part of the
robot.  The methods allow planning algorithms to determine whether any
of the robot parts are in collision with each other or with obstacles
in the world.  </li> <p>

<li><b><a href="class_Problem.html">Problem</a>:</b> This is an interface
class to a planner, which abstracts the designer of a planning
algorithm away from particular details such as collision detection,
and dynamical simulations.  Each instance of a problem includes both
an instance of Model and of Geometry.  An initial state and final
state are also included, which leads to a problem to be solved by a
solver (typically a planning algorithm).  </li> <p>

<li><b><a href="class_Solver.html">Solver</a>:</b> There is currently
only one kind of solver, which is a hierarchy of planners.
A Solver is initialized with an
instance of Problem, and a method searches for a motion strategy that
solves a problem.  </li> <p>

<li><b><a href="class_Scene.html">Scene</a>:</b> This is an interface
class that computes configurations of all bodies to be displayed by a
rendering method.  Scene receives most of its information directly
from Problem, but includes additional information relevant to
rendering, such as camera viewpoint.  </li> <p>

<li><b><a href="class_Render.html">Render</a>:</b> This hierarchy of
classes contains different implementations of graphical rendering
requests.  For example, when a graphical user interface (GUI) requests
that the a solution path is animated, a method in a Render class
displays the bodies in motion using configurations obtained from the
Scene class.  Each derived class in Render corresponds to a different
graphics system.  Presently, there are renderers for SGI IRIS
Performer, Open Inventor, Open GL.  The flexibility provided
by these classes enables easy extensions to be made for other graphics
libraries and platforms.  </li> <p>

<li><b><a href="class_Gui.html">Gui</a>:</b> The graphical user interface
(GUI) is designed as a hierarchy of classes to enable specific user
interfaces to be designed for a variety of different motion strategy
problems and planning algorithms.  Currently, there is one derived
class which serves as the GUI for all of the RRT-based planners.  Each
instance of Gui includes an instance of an RRT Planner class and an
instance of a Render class.  Using this design, the same basic GUI
design can be used, regardless of the particular rendering methods.
</li> <p>

</ul>

<hr>

<h2><A NAME="B">B. Downloading and Installation</h2>

Here is the download information:<p>

<font size=6>MSL Release 2.0 (07/22/03)</font> <p>

Source distribution: 
<a href="http://msl.cs.uiuc.edu/msl/msl-2.0.tar.gz">
[gzipped tar file]</a><br>
Linux binary distribution (Compiled using Red Hat 7.2): 
<a href="http://msl.cs.uiuc.edu/msl/msl-2.0-rh7.2-bin.tar.gz">
[gzipped tar file]</a> <br>
Linux binary distribution (Compiled using Red Hat 8.0): 
<a href="http://msl.cs.uiuc.edu/msl/msl-2.0-rh8.0-bin.tar.gz">
[gzipped tar file]</a> <br>
</li>

<p>

For information about the new version, see the 
<A HREF="#D">Revision History</A><br>

<p>

<a href="oldreleases.html">OLD RELEASES</a>

<p>

MSL was developed on a PC running Red Hat Linux.  Therefore
installation will probably be easiest on this platform.  Versions of the software
has also successfully been installed on an SGI, SunOS, Windows 2000,
and many other flavors of Linux.<p>

The following libraries are used by MSL:

<ul>
<li><a href="http://www.fox-toolkit.org/">FOX C++ GUI Toolkit</a>

This library is free for use under an LGPL license with a relinking
exemption addendum.
<p>

</li>
<li><a href="http://www.cs.unc.edu/~geom/SSV/">Proximity Query Package 
(PQP)</a>

This package was developed at the University of North Carolina, and is
free for noncommerical use.  It performs efficient collision detection and
distance computations for a collection of triangles in a 3D world.
PQP is generally easy to install.  We have been playing around with
our own implementations of collision detection algorithms, and there is
a chance that future MSL version will not require PQP.
<p>
</li>

<li><a href="http://www.opengl.org/">Open GL</a>, <a
href="http://www.opengl.org/developers/documentation/glut/index.html">GLUT</a>

OpenGL (or an equivalent API, such as MesaGL) is required for 3D
rendering using the GL-based renderer.  The needed libraries can be
obtained for free on most platforms (for example, they are included in
RedHat Linux distributions).  The library files are libglut, libGLU,
and libGL.  The file libglut comes from the glut package, which
provides some GL utilities.  If you are using Linux and want great
graphics performance, then you have to pay special attention to the
integration of a good graphics card, good Linux driver, GLX, and GL.
We have had the best luck using <a
href="http://www.nvidia.com">NVIDIA</a> cards because great Linux
drivers are available from the NVIDIA web pages.

The most helpful web pages are: <a
href="http://www.opengl.org/">OpenGL</a>, <a
href="http://www.opengl.org/developers/documentation/glut/index.html">GLUT</a> 
and <a
href="http://www.mesa3d.org/">Mesa3D</a> (Mesa3D is an alternative to
OpenGL).
<p>

</li>

<li><a href="http://oss.sgi.com/projects/inventor/">Open Inventor</a>

This library is required ONLY if you want to use the Inventor-based
renderer.  It currently has all of the features of the GL-based renderer,
plus a few more.  We recommend using this one if you can.  Open Inventor
is available as Open Source under the LGPL license.
</li>
<p>

<li><a href="http://www.sgi.com/software/performer/">OpenGL
Performer</a>

This library is required ONLY if you want to use the Performer-based
renderer.  This library is only desirable if you want to develop
high-performance graphics with the MSL.  It is also necessary, of
course, if you want to use Performer models.  The MSL example of a car
driving through a nicely-rendered town is an example of such a model.
At the present time, Performer is available for SGIs and is free for
Linux.  The Linux information is given on the <a
href="http://www.sgi.com/software/performer/linux.html"> Performer
for Linux page</a>.
</li>
<p>

</ul>


<hr>

<h2><A NAME="C">C. Help Getting Started</h2> 

Several README files are contained within the distribution.
These contain useful information regarding installation,
running examples, and developing your own code that uses the 
library.

<h3>Runnning the examples</h3>

In the default configuration, two executables are generated, plangl
and planleda.  When running either of these, a path must be specified
that contains the problem.  There are many example problems in the
data directory.  To run one, type "plangl data/cage1".

<h3>The GuiPlanner window</h3>

<img align=left src="mslgui.jpg"> <br clear=all>

The Construct button generates a planning graph, but does not attempt
to solve the problem.  Plan attempts to find a path that connects the
InitialState to the GoalState (the PRM planner requires first using
Construct; RRT-based planners do not).  If Plan fails, it can be
pressed again and the planner will continue to search using the
previous planning graphs as a starting point.  The Planner menu allows
different planners to be attempted.  The Display menu has functions
that show a solution path or show a 2D projection of the planning
graph.  By default, the projection is shown using the first two state
varibles.  In the planner control window the variables DrawIndexX
and DrawIndexY can be used to select other state variables to show in
the projection.  The File menu contains many straightforward options
to read and write files.  The Settings menu allows some planning
parameters to be adjusted, including DeltaT (the time step), NumNodes
(number of nodes to try to make each time Plan is pressed), and
GapDist (the distance threshold to use to declaring a connection has
been made in a dual tree search algorithm).


<h3>The GL renderer</h3>

<img align=left src="mslgl.jpg"> <img src="mslglm.jpg"> 
<br clear=all>

The GL rendering window is primarily controlled using the render
control window.  Some of the render control options can be performed
by pressing keys.  Press 'h' to see a listing of these.  Holding each
mouse button while moving allows a different type of change in the
viewpoint.

<h3>The Inventor Renderer</h3>

<img align=left src="msliv.jpg">
<br clear=all>

You can grab onto the environment and spin it.

<h3>The Performer renderer</h3>

<img align=left src="mslpf.jpg"> <img src="town.jpg"> 
<br clear=all>

When the Performer rendering window is open, there are several ways to
interact with the display.  Pressing "c" will show or hide a control
bar that changes the animation speed.  Pressing "b" will show or hide
a bounding box that is based on LowerWorld and UpperWorld.  Pressing
"v" changes the viewpoint from either being global or being attached
to a body.  Holding each mouse button while moving allows a different
type of change in the viewpoint.


<h3>Making a new problem</h3>

Each problem is described by a directory full of files.  Most of them
are ASCII files that are easily read and written.  To make a
new example, some files are necessary, while others are optional.
Default values of parameters will be assumed when optional files are
not present.  Some particular models might require files that are not
used in other models.  For example, ModelLinear requires files "A" and
"B" which specify the matrices in the equation xdot = Ax + Bu.  Other
than reading the code, an easy way to find out which files might be
needed for a particular model is to modify an example that has been
included in this distribution and uses the same model. <p>

The following files are required for all examples:
<ul>

<li> GeomDim: The dimension of the environment (2 or 3)

<li> ModelXXX: A file named exactly after the motion model to be used.  
Examples are Model2DRigid and Model3DRigidMulti.

<li> GeomXXX: A file named exactly after the geometry model, such as
GeomPQP3DRigid for a rigid body made of triangles in a 3D world (with
PQP being used for collision detection).

<li> IntialState: The initial state for the problem.

<li> GoalState: The desired goal state.

<li> Robot: A model of the robot, specified either as a list of
polygons if GeomDim = 2, or a list of 3D triangles if GeomDim = 3.
For problems that involve multiple bodies, the robots are named
Robot0, Robot1, ..., Robotk, for k robots.
</ul>

The following files are optional:
<ul>
<li> ModelDeltaT: The time increment to be used for numerical integration
of the state transition equation (equations of motion).

<li> PlannerDeltaT: The time increment to be used for an incremental
planning step.

<li> Obst: A list of stationary obstacles, specified either as a list
of polygons if GeomDim = 2, or a list of 3D triangles if GeomDim
= 3.

<li> EnvList: A list of file names that correspond to stationary
geometric models that can be loaded and rendered (they are not used
for collision detection).  If EnvList does not exist, then Obst is
loaded and rendered.

<li> BodyList: A list of file names that correspond to movable bodies.
If BodyList does not exist, then Robot, or Robot0, Robot1, ..., Robotk
are loaded.

<li> LowerState: The lowest possible state vector.  Each element is
the smallest value for that state variable.

<li> UpperState: The highest possible state vector.  Each element is
the largest value for that state variable.

<li> RRTXXX: A default planner selection, such as RRTExtExt or
RRTConCon.

<li> Inputs: A list of input vectors to be applied to the state
transition equation.  By making this file, one can override the
defaults from the class constructor.  For example, an car that can go
forward or reverse can be converted into a forward-only car by simply
changing this file.

<li>ViewingPosition: The (x,y,z) position of the camera to be used in
rendering.

<li>ViewingDirection: The direction that the camera should point (a 3D
vector)

<li>ViewingOrientation: A possible rotation about the viewing
direction for the camera.

<li>LowerWorld: The smallest (x,y,z) value of the environment.

<li>UpperWorld: The largest (x,y,z) value of the environment. 

<li>Holonomic: Let a planner know that the problem is holonomic with a
state transition equation of the form xdot = u.  In this case,
performance can be greatly improved by ignoring the Inputs and
performing linear interpolation to generate local motions.
</ul>



<h3>Extending existing models</h3>

Suppose that you would like to make your model derived class from
Model, or you would like to make your own variation of an RRT, PRM, or
FDP planner.  This can be accomplished by writing very little code.
An example of how to make and use your own model is given in the
"tests" directory of the MSL distribution.  Included in that
directory is a README that explains the examples.  These are the
recommended way to use the MSL in a clean, object-oriented way.
If you write code this way and make some interesting contributions,
it will be easy for us to include it in future releases of the
library.  If you simply hack away at the MSL source code, then it
will be nearly impossible to do this, and you will have difficulty
using upgraded versions of MSL.

<hr>

<h2><A NAME="D">D. Known Problems</h2> 

<b>Version 2.0 </b>

<ul>

<li>For solutions generated by any RRT planner with "Con" in the name, the
animated path might appear incorrect for nonholonomic planning problems.
This is because linear interpolation is used between far away states
that are given for rendering.  The algorithms still correctly compute the
trajectory using numerical integration (only the display is wrong).
<li>ANYTHING ELSE WE WANT TO ADD HERE????

</ul>

<hr>

<h2><A NAME="E">E. Revision History</h2> 

I get many messages from researchers attempting to get the MSL to work
on Windows platforms.  My student, Libo Yang took an MSL version from
a couple of years ago and fixed the code up to work under Windows
2000.  Beyond that, we do not have the resources to maintain the code
for various Windows distributions, such as NT or XP.  Once we release
the new open source version this summer, we would welcome any
contributions that help make the MSL work under these platforms.  We
generally do our development in Linux, and do not have the expertise
or desire to provide extensive support for Windows.  However, since
many users care about this, we are willing to incoprorate the
contributions of others, which may enable the library to be compiled
under various Windows platforms.


<ul>
 
 <li><b>Version 2.0 (7/22/03)</b><br> After two years of being at the 
University of Illinois, we have finally released a new version, which
is substantially updated.
  <ul>
<li>Under some Linux platforms, the GL-based animation got stuck due to some
strange event handling problems (might be caused by problems in FOX).
You'll no longer have to jiggle the mouse to get the animations moving.
<li>The Performer renderer and GUI are working again, for the first time
under non-LEDA versions of MSL.  This enables very sophisticated models
to be used.
<li>The Inventor-based GUI is much enhanced now.  It has all of the 
features of the GL-based GUI.
<li>The PRM implementations were very primitive.  There are now improved
version that use the union-find algorithm to do fast connected-component 
analysis.  This greatly improves PRM performance.
<li>The timings were messed up after saving and loading a computed trajectory.
This is fixed.
<li>The triangle orientations generated by the code in the util directory,
and in many example problems, were messed up.  This made the shading wrong
in the renderers.  This is fixed.
<li>Some newer RRT-based planning algorithms have been added.
<li>More planning examples, including straightforward examples of
the 3D articulated body class, to make it easier to construct new
examples.
<li>The Euler angles for 3D rotation were given a range for the example
problems that resulted in a double cover of the configuration space.  The
3D rotation code has been simplified to make debugging easier, and the 
examples have been fixed.
  </ul>
 <li><b>Version 1.2nl [non-LEDA] (9/1/01)</b> 
  <ul>
    <li> This is the first version that was written without LEDA.  Most
         of the original functionality of MSL Version 1.2 was preserved.
    <li> A render based on OpenInventor was added.  Multiple cameras
         and attached cameras are not supported.
  </ul>
 <li><b>Version 1.2 (1/9/01)</b> 
  <ul>
    <li> A new default renderer has been made based on GL and GLUT.  This
         greatly increases the portability of MSL.  Features are described
         above.
    <li> All of the animation frame handling is done in the Render base class.
         This facilitates the design of a new renderer.
    <li> A render control window is available (describe above).
    <li> A bidirectional version of FDP has been added.
  </ul>
 <li><b>Version 1.1 (12/15/00)</b> 
  <ul>
    <li> Animations in a rendering window are now displayed at a
         rate given by the times associated with each state (generated
         by a planner).  On a slower graphics card, frames are simply 
         skipped to maintain the proper speed.  The control bar allows
         the time to be scaled, allowing the animation to be anywhere
         from 1000 times slower to 1000 times faster.
    <li> New models were added to support a collection of attached
         3D bodies: Model3DRigidChain and Model3DRigidTree.  New examples
         were added to demonstrate these new models: 3dchain1, 3dtree1.
    <li> Pressing "v" in the Performer rendering window will change the
         viewpoint to be attached to a body.  New variables were added
         to Scene to specify the camera parameters.  These variables can be 
         read in from files.
    <li> A Probabilistic Roadmap Planner (PRM) was added, based on the
         approach of Kavraki, Svestka, Latombe, Overmars, 1994.
    <li> A Forward Dynamic Programming (FDP) planner was added, based
         on the approach of Barraquand, Latombe, Algorithmica, 1993.
         There are two derived classes, FDPStar (an A* search variant),
         and FDPBestFirst (a best-first search variant).  These methods
         are grid-based, and are therefore limited to a few dimensions
         (four or less in most circumstances).  Under data, the directories
         fdp1 and fdp2 contain examples.
    <li> RRTCon is now derived from RRTGoalBias.  By default, there is
         no bias.  A file named GoalProb can be used to override the
         default.
    <li> The bidirectional RRT planners use a new variable called 
         ConnectTimeLimit.  If this time limit is reached (starting
         at time zero when the connection begins), then the connection
         is stopped, even if the sample is not reached.  Note that this
         is not real time, but time according to the integrations of 
         the model.  A file named ConnectTimeLimit can be defined to
         override the default (infinity).
    <li> GapDist has been replaced by a vector called GapError.  RRT-based
         planners will consider connection to be made if the absolute value
         of the difference between each state component is less than or equal
         to the corresponding component of GapError.
    <li> A number of minor bugs were fixed.
  </ul>

 <li><b>Version 1.0.1 (11/15/00)</b> 

  <ul>
    <li> A Solver base class has been defined, with Planner as a
child.  RRT is a child of Planner.  The GUI for the RRT planner has
been generalized to accomodate other planners more easily.  Hence,
GuiRRT is replaced with GuiPlanner.  "rrtpf" and "rrtleda" are
replaced with "planpf" and "planleda".  The files "rrtpf.C",
"rrtleda.C", "guirrt.C", "guirrt.h" have been replaced with
"planpf.C", "planleda.C", "guiplanner.C", "guiplanner.h".  The new
base classes are in "solver.h" and "planner.h".

    <li> The step sizes for numerical integration and for planning can
now be controlled independently.  For a problem, make a file called 
ModelDeltaT to set the numerical integration step time, and PlannerDeltaT
for the planner.  Default values have been set for the examples.  Note that
if PlannerDeltaT is too large, then the collision checker might miss
collisions that occur from intermediate configurations.
    <li> Minor bugs were fixed in the examples and in the code.  
  </ul>
 </li>

<li><b>Version 1.0 (11/11/00)</b> The original distribution.
</ul>

<hr>


<h2><A NAME="F">F. To-Do List</h2> 

<ul>
<li>ANYTHING TO PUT HERE????
</ul>


<hr>

<h2><A NAME="G">G. Contributors</h2> 

<ul>
<li><b>Peng Cheng</b><br>
GL-based renderer.  Some RRT classes.
</li>
<li><b>James Kuffner</b><br>
Original Inventor renderer.  Help with design of basic classes.
</li>
<li><b>Steve LaValle</b><br>
Supervision of project.  Most of the design and implementation of 
basic classes.  Implementation of most RRT, Model, and Geom classes.
</li>
<li><b>Steve Lindemann</b><br>
Many bug fixes.  Improved PRM implementations.
</li>
<li><b>Aswath Manohar</b><br>
Many bug fixes.  Enhanced Inventor renderer and FOX GUI.
</li>
<li><b>Benjamin Tovar</b><br>
Improved installation scripts.
</li> 
<li><b>Libo Yang</b><br>
Performer renderer.  Help with design of basic classes.
</li>
<li><b>Anna Yershova</b><br>
3DChain, 3DTree classes.
</li>
<br>
</ul>

Web page maintained by <a href="http://msl.cs.uiuc.edu/~lavalle">Steve
LaValle</a> and his students at the University of Illinois.<br>
